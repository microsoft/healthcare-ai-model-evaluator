# /.azure-pipelines/msdo-static-scan.yml
# Static security scan for .NET + React using Microsoft Security DevOps (MSDO)

trigger:
  branches:
    include: [ main ]
pr:
  branches:
    include: [ main, develop, feature/* ]

pool:
  vmImage: 'ubuntu-latest'  
variables:
  DOTNET_VERSION: '8.0.x'
  NODE_VERSION: '23.x'
  BUILD_CONFIGURATION: 'Release'
  SOLUTION: 'backend/*.sln'

steps:
  - checkout: self
    fetchDepth: 0

  - task: UseDotNet@2
    inputs:
      packageType: 'sdk'
      version: '$(DOTNET_VERSION)'

  - task: NodeTool@0
    inputs:
      versionSpec: '$(NODE_VERSION)'

  # Build so BinSkim can analyze binaries
  - script: |
      dotnet restore $(SOLUTION)
      dotnet build $(SOLUTION) -c $(BUILD_CONFIGURATION) --no-restore
    displayName: 'Restore & Build (.NET)'

  # Run .NET tests with code coverage
  - script: |
      mkdir -p TestResults
      dotnet test $(SOLUTION) \
        --configuration $(BUILD_CONFIGURATION) \
        --no-build \
        --collect:"XPlat Code Coverage" \
        --results-directory TestResults \
        --logger trx \
        --settings backend/CodeCoverage.runsettings
    displayName: 'Run .NET Tests with Coverage'
    continueOnError: true

  # Install ReportGenerator for coverage reports
  - script: |
      dotnet tool install -g dotnet-reportgenerator-globaltool
      echo '##vso[task.prependpath]$HOME/.dotnet/tools'
    displayName: 'Install ReportGenerator'

  # Generate HTML coverage report
  - script: |
      # Find the coverage files (they're in GUID-named directories)
      COVERAGE_FILES=$(find TestResults -name "coverage.cobertura.xml" -type f)
      
      if [ -z "$COVERAGE_FILES" ]; then
        echo "No coverage files found!"
        exit 1
      fi
      
      echo "Found coverage files: $COVERAGE_FILES"
      
      # Convert newline-separated list to semicolon-separated for ReportGenerator
      COVERAGE_REPORTS=$(echo "$COVERAGE_FILES" | tr '\n' ';' | sed 's/;$//')
      
      echo "Coverage reports parameter: $COVERAGE_REPORTS"
      
      # Generate the report using found files
      reportgenerator \
        -reports:"$COVERAGE_REPORTS" \
        -targetdir:"TestResults/CoverageReport" \
        -reporttypes:"Cobertura;XMLSummary"
    displayName: 'Generate Coverage Report'
    condition: succeededOrFailed()

  # Publish test results
  - task: PublishTestResults@2
    condition: succeededOrFailed()
    inputs:
      testResultsFormat: 'VSTest'
      testResultsFiles: 'TestResults/**/*.trx'
      publishRunAttachments: true

  # Publish code coverage results
  - task: PublishCodeCoverageResults@2
    condition: succeededOrFailed()
    inputs:
      codeCoverageTool: 'Cobertura'
      summaryFileLocation: 'TestResults/CoverageReport/Cobertura.xml'
      pathToSources: 'backend/src/'
      failIfCoverageEmpty: false

  # Alternative: Try to publish original coverage files if ReportGenerator fails
  - task: PublishCodeCoverageResults@2
    condition: failed()
    inputs:
      codeCoverageTool: 'Cobertura'
      summaryFileLocation: 'TestResults/**/coverage.cobertura.xml'
      pathToSources: 'backend/src/'
      failIfCoverageEmpty: false

  # --- Frontend tests and coverage
  - script: |
      cd frontend
      echo "Installing frontend dependencies..."
      npm ci
    displayName: 'Install Frontend Dependencies'

  - script: |
      cd frontend
      echo "Running frontend tests with coverage..."
      npm run test -- run --coverage --reporter=verbose --reporter=json --outputFile.json=./test-results.json
    displayName: 'Run Frontend Tests with Coverage'
    continueOnError: true

  # Publish frontend test results
  - task: PublishTestResults@2
    condition: succeededOrFailed()
    inputs:
      testResultsFormat: 'JUnit'
      testResultsFiles: 'frontend/test-results.json'
      testRunTitle: 'Frontend Tests'
      publishRunAttachments: true
    continueOnError: true

  # Publish frontend code coverage
  - task: PublishCodeCoverageResults@2
    condition: succeededOrFailed()
    inputs:
      codeCoverageTool: 'Cobertura'
      summaryFileLocation: 'frontend/coverage/cobertura-coverage.xml'
      pathToSources: 'frontend/src/'
      failIfCoverageEmpty: false

  # --- Install scanners
  - script: |
      # DevSkim (SAST patterns for many languages)
      dotnet tool install -g Microsoft.CST.DevSkim.CLI
      echo '##vso[task.prependpath]$HOME/.dotnet/tools'

      # BinSkim (binary hardening checks)
      dotnet tool install -g Microsoft.CodeAnalysis.BinSkim

      # ESLint + security plugins
      npm i -D eslint eslint-plugin-security eslint-plugin-react eslint-plugin-jsx-a11y eslint-plugin-no-unsanitized

      # Trivy (deps/secrets/misconfig)
      sudo apt-get update -y
      sudo apt-get install -y wget apt-transport-https gnupg lsb-release
      wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo gpg --dearmor -o /usr/share/keyrings/trivy.gpg
      echo "deb [signed-by=/usr/share/keyrings/trivy.gpg] https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
      sudo apt-get update -y && sudo apt-get install -y trivy
    displayName: 'Install security tools'

  # --- Run scanners (emit SARIF)
  - script: |
      mkdir -p CodeAnalysisLogs

      # DevSkim
      devskim analyze --output CodeAnalysisLogs/devskim.sarif --ignore-globs node_modules/** --severity medium || true

      # ESLint (React/TS)
      npx eslint "src/**/*.{js,jsx,ts,tsx}" -f sarif -o CodeAnalysisLogs/eslint.sarif || true

      # BinSkim (scan built artifacts)
      binskim analyze "$(Build.SourcesDirectory)/**/bin/**" --recurse --output CodeAnalysisLogs/binskim.sarif || true

      # Trivy filesystem scan (deps, secrets, misconfig)
      trivy fs --scanners vuln,secret,misconfig --format sarif -o CodeAnalysisLogs/trivy.sarif .
    displayName: 'Run SAST & artifact scans'
    continueOnError: true

  # Publish SARIF for download / dashboards
  - task: PublishBuildArtifacts@1
    condition: succeededOrFailed()
    inputs:
      PathtoPublish: 'CodeAnalysisLogs'
      ArtifactName: 'CodeAnalysisLogs'
      publishLocation: 'Container'
